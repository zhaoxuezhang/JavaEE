<html>
<head>
  <title>2、设计原则</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601935 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1254"/>
<h1>2、设计原则</h1>

<div>
<span><div><div><span style="font-size: 16pt; font-family: Consolas;">一、单一职责原则</span></div><div><span style="font-size: 16pt; font-family: Consolas;">    定义：<font style="color: rgb(255, 0, 0);">一个类应该只负责一项职责。</font></span></div><ul><li><div><span style="font-size: 16pt; font-family: Consolas;">1、降低类的复杂度，一个类只负责一项职责；</span></div></li><li><div><span style="font-size: 16pt; font-family: Consolas;">2、提高可读性；</span></div></li><li><div><span style="font-size: 16pt; font-family: Consolas;">3、降低变更引起的风险；</span></div></li><li><div><span style="font-size: 16pt; font-family: Consolas;">4、通常情况下，应当遵守单一职责原则。</span></div></li></ul><hr/><div><span style="font-size: 16pt;">二、接口隔离原则</span></div><div><span style="font-size: 16pt;">      定义：客<font style="color: rgb(255, 0, 0);">户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。</font></span></div><hr/><div><span style="font-family: Consolas; font-size: 16pt;">三、依赖倒置原则</span></div><div><span style="font-family: Consolas; font-size: 16pt;"> 1、定义：</span></div><ul><li><div><span style="font-family: Consolas; font-size: 16pt;">高层模块不应该依赖低层模块，二者都应该依赖其抽象；</span></div></li><li><div><span style="font-family: Consolas; font-size: 16pt;">抽象不应该依赖细节，细节应该依赖抽象</span></div></li><li><div><span style="font-family: Consolas; font-size: 16pt;"><font style="color: rgb(255, 0, 0);">依赖倒置得中心思想是面向接口编程</font></span></div></li><li><div><span style="font-family: Consolas; font-size: 16pt;">依赖倒置原则是基于这样得设计理念：相对于细节的多变性，抽象的东西要稳定的多，以抽象为基础搭建的框架比以细节为基础的架构要稳定的多。再Java中，抽象指的是接口或抽象类，细节就是具体的实现类。</span></div></li><li><div><span style="font-family: Consolas; font-size: 16pt;">使用接口或抽象类的目的是制定好规范，不涉及任何的具体操作，把展现细节的任务交给他们的实现类处理。</span></div></li></ul><div><span style="font-size: 16pt; font-family: Consolas;">2、依赖关系的三种传递方法：</span></div><ul><li><div><span style="font-size: 16pt; font-family: Consolas;">通过接口传递实现依赖</span></div></li><li><div><span style="font-size: 16pt; font-family: Consolas;">通过构造器实现依赖</span></div></li><li><div><span style="font-size: 16pt; font-family: Consolas;">通过setter方法实现依赖</span></div></li></ul><hr/><div><span style="font-size: 16pt; font-family: Consolas;">四、里氏替换原则</span></div><div><span style="font-size: 16pt; font-family: Consolas;">    <font style="color: rgb(255, 0, 0);">解决继承中的问题</font></span></div><div><span style="font-size: 16pt; font-family: Consolas;">    定义1：如果对每一个类型为S的对象o1，都有类型为T的对</span><span style="font-family: Consolas; font-size: 16pt;">象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变</span><span style="font-family: Consolas; font-size: 16pt;">化，那么类型S是类型T的子类型。</span></div><div><span style="font-size: 16pt; font-family: Consolas;">    定义2：<font color="#FF0000">所有引用基类的地方必须能透明地使用其子类的</font></span><span style="font-family: Consolas; font-size: 16pt;"><font color="#FF0000">对象。</font></span></div><hr/><div><span style="font-family: Consolas; font-size: 16pt;">五、 开闭原则</span></div><div><span style="font-size: 16pt; font-family: Consolas;">    Software entities like classes,modules and functions should be open for extension but closed for</span></div><div><span style="font-size: 16pt; font-family: Consolas;">modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）</span></div><div><span style="font-size: 16pt; font-family: Consolas;">开闭原则的定义已经非常明确地告诉我们：<font color="#FF0000">软件实体应该对扩展开放，对修改关闭，其</font></span><span style="font-family: Consolas; font-size: 16pt;"><font color="#FF0000">含义是说一个软件实体应该通过扩展来实现变化而不是通过修改已有的代码来实现变化。</font></span><span style="font-family: Consolas; font-size: 16pt;">那什么又是软件实体呢？软件实体包括以下几个部分：</span></div><div><span style="font-size: 16pt; font-family: Consolas;">● 项目或软件产品中按照一定的逻辑规则划分的模块。</span></div><div><span style="font-size: 16pt; font-family: Consolas;">● 抽象和类。</span></div><div><span style="font-size: 16pt; font-family: Consolas;">● 方法。</span></div><hr/><div><span style="font-size: 16pt; font-family: Consolas;">六、迪米特原则</span></div><div><span style="font-size: 16pt; font-family: Consolas;">    迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge </span><span style="font-size: 16pt; font-family: Consolas;">Principle，LKP），虽然名字不同，但描述的是同一个规则：<font color="#FF0000">一个对象应该对其他对象有最</font></span><span style="font-family: Consolas; font-size: 16pt;"><font color="#FF0000">少的了解。</font>通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调</span><span style="font-family: Consolas; font-size: 16pt;">用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public</span><span style="font-family: Consolas; font-size: 16pt;">方法，我就调用这么多，其他的我一概不关心。</span></div><div><span style="font-size: 16pt; font-family: Consolas;">1. 只和朋友交流</span></div><div><span style="font-size: 16pt; font-family: Consolas;">   迪米特法则还有一个英文解释是：Only talk to your immediate friends（只与直接的朋友通</span><span style="font-family: Consolas; font-size: 16pt;">信。）什么叫做直接的朋友呢？每个对象都必然会与其他对象有耦合关系，两个对象之间的</span><span style="font-family: Consolas; font-size: 16pt;">耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。</span></div><div><span style="font-size: 16pt; font-family: Consolas;">2. 朋友间也是有距离的</span></div><div><span style="font-size: 16pt; font-family: Consolas;">   一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散</span><span style="font-family: Consolas; font-size: 16pt;">也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少</span><span style="font-family: Consolas; font-size: 16pt;">public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前</span><span style="font-family: Consolas; font-size: 16pt;">不加访问权限，则默认为包类型）、protected等访问权限，是否可以加上final关键字等。</span></div><div><span style="font-size: 16pt; font-family: Consolas;">    <font style="color: rgb(255, 0, 0);">注意</font>　迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的</span><span style="font-family: Consolas; font-size: 16pt;">public变量，尽量内敛，多使用private、package-private、protected等访问权限。</span></div><div><span style="font-size: 16pt; font-family: Consolas;">3. 是自己的就是自己的</span></div><div><span style="font-size: 16pt; font-family: Consolas;">   在实际应用中经常会出现这样一个方法：放在本类中也可以，放在其他类中也没有错，</span><span style="font-family: Consolas; font-size: 16pt;">那怎么去衡量呢？你可以坚持这样一个原则：如果一个方法放在本类中，既不增加类间关</span><span style="font-family: Consolas; font-size: 16pt;">系，也对本类不产生负面影响，那就放置在本类中。</span></div><div><span style="font-size: 16pt; font-family: Consolas;">4. 谨慎使用Serializable</span></div><div><span style="font-size: 16pt; font-family: Consolas;">   在实际应用中，这个问题是很少出现的，即使出现也会立即被发现并得到解决。是怎么</span><span style="font-family: Consolas; font-size: 16pt;">回事呢？举个例子来说，在一个项目中使用RMI（Remote Method Invocation，远程方法调</span><span style="font-family: Consolas; font-size: 16pt;">用）方式传递一个VO（Value Object，值对象），这个对象就必须实现Serializable接口（仅</span><span style="font-size: 16pt; font-family: Consolas;">仅是一个标志性接口，不需要实现具体的方法），也就是把需要网络传输的对象进行序列</span><span style="font-family: Consolas; font-size: 16pt;">化，否则就会出现NotSerializableException异常。</span><span style="font-size: 16pt; font-family: Consolas;">突然有一天，客户端的VO修改了一个属性</span><span style="font-family: Consolas; font-size: 16pt;">的访问权限，从private变更为public，访问权限扩大了，如果服务器上没有做出相应的变</span><span style="font-family: Consolas; font-size: 16pt;">更，就会报序列化失败，就这么简单。但是这个问题的产生应该属于项目管理范畴，一个类</span><span style="font-family: Consolas; font-size: 16pt;">或接口在客户端已经变更了，而服务器端却没有同步更新，难道不是项目管理的失职吗？</span></div><div><span style="font-size: 16pt; font-family: Consolas;">    迪米特法则的核心观念就是<font style="color: rgb(186, 0, 255);">类间解耦，弱耦合</font>，只有弱耦合了以后，类的复用率才可以</span><span style="font-family: Consolas; font-size: 16pt;">提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维</span><span style="font-family: Consolas; font-size: 16pt;">护带来了难度。采用迪米特法则时需要反复权衡，既做到让结构清晰，又做到高内聚</span><span style="font-family: Consolas; font-size: 16pt;">低耦合。</span></div><hr/><div><span style="font-family: Consolas; font-size: 16pt;">七、合成复用原则</span></div><div><span style="font-family: Consolas; font-size: 16pt;">原则是尽量使用合成/聚合的方式，而不是继承。</span></div><div><span style="font-family: Consolas; font-size: 16pt;"><br/></span></div><div><span style="font-family: Consolas; font-size: 16pt;"><br/></span></div><div><span style="font-family: Consolas; font-size: 16pt;"><br/></span></div><div><span style="font-family: Consolas; font-size: 16pt;"><br/></span></div><div><span style="font-family: Consolas; font-size: 16pt;"><br/></span></div><div><span style="font-family: Consolas; font-size: 16pt;"><br/></span></div><div><span style="font-family: Consolas; font-size: 16pt;"><br/></span></div><div><span style="font-family: Consolas; font-size: 16pt;"><br/></span></div><div><span style="font-family: Consolas; font-size: 16pt;"><br/></span></div><div><span style="font-family: Consolas; font-size: 16pt;"><br/></span></div><div><span style="font-family: Consolas; font-size: 16pt;"><br/></span></div><br/><hr/></div><div><br/></div></span>
</div></body></html> 